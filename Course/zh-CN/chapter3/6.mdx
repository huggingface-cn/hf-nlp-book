<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# 章末小测验 [[章末小测验]]

<CourseFloatingBanner
    chapter={3}
    classNames="absolute z-10 right-0 top-0"
/>

现在来测试一下本章所学内容吧！

### 1.“情绪”数据集包含标记有情绪的 Twitter 消息。请在 [ Hub ]( https://huggingface.co/datasets) 中进行搜索并读取数据集卡。判断哪一个不是基本情感？
<Question
	choices={[
		{
			text: "Joy",
			explain: "再试一次ーー这种情绪出现在那个数据集中！"
		},
		{
			text: "Love",
			explain: "再试一次ーー这种情绪出现在那个数据集中！"
		},
		{
			text: "Confusion",
			explain: "正确! Confusion不是六种基本情绪之一。",
            correct: true
		},
        {
			text: "Surprise",
			explain: "Surprise! 再试一次！"
		}
	]}
/>

### 2．在 [ Hub ]( https://huggingface.co/datasets) 中搜索`ar _ `数据集，该数据集支持哪个任务？
<Question
	choices={[
		{
			text: "情绪分类",
			explain: "没错! 多亏这些标签。",
            correct: true
		},
		{
			text: "机器翻译",
			explain: "啊哦，再看看 ＋－｜－－5－－｜－＋ dataset card ＋－｜－－6－－｜－＋ ！"
		},
		{
			text: "命名实体识别",
			explain: "啊哦，再看看 ＋－｜－－7－－｜－＋ dataset card ＋－｜－－8－－｜－＋ ！"
		},
        {
			text: "回答问题",
			explain: "啊哦， 再试一次！"
		}
	]}
/>

### 3.BERT 模型期望如何处理一对句子？
<Question
	choices={[
		{
			text: "Tokens_of_sentence_1 [ SEP ] Tokens_of_sentence_2",
			explain: "在创建批处理时确实意味着填充，但不意味着填充到整个数据集中的最大长度。"
		},
		{
			text: "[CLS] Tokens_of_sentence_1 Tokens_of_sentence_2",
			explain: "一个 ＋－｜－－9－－｜－＋ [ CLS ] ＋－｜－－10－－｜－＋ 特殊token在开始时是必需的，但不代表只需要这一个"
		},
		{
			text: "[CLS] Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2 [SEP]",
			explain: "正确！",
            correct: true
		},
        {
			text: "[CLS] Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2",
			explain: "开头需要一个 ＋－｜－－11－－｜－＋ [ CLS ] ＋－｜－－12－－｜－＋ 特殊token，还需要一个 ＋－｜－－13－－｜－＋ [ SEP ] ＋－｜－－14－－｜－＋ 特殊token来分隔两个句子，但这还不是全部。"
		}
	]}
/>

{#if fw === 'pt'}
### 4.`Dataset.map ()`方法的好处是什么？
<Question
	choices={[
		{
			text: "该函数执行后的结果被缓存，重新执行代码时不会花费多余时间。",
			explain: "这确实是这种方法的优点之一! 不过还有别的优点...",
            correct: true
		},
		{
			text: "它可以进行多重处理，比在数据集的每个元素上应用函数更快。",
			explain: "这是该方法一个比较优雅的特点！ 不过还有别的优点...",
            correct: true
		},
		{
			text: "它只包含用于训练的超参数。",
			explain: "这是这种方法的一个优点！ 不过还有别的优点...",
            correct: true
		},
	]}
/>

### 5．什么是动态填充？
<Question
	choices={[
		{
			text: "就是将每个批处理的输入填充到整个数据集中的最大长度。",
			explain: "在示例中，我们指定了保存模型及其检查点的位置。请再试一次！"
		},
		{
			text: "当你填补你的输入时，批处理创建，接着到最大长度的句子里面的批处理。",
			explain: "没错！“动态”部分即每个批的大小是在创建时确定的，因此所有批可能具有不同的形状。",
            correct: true
		},
		{
			text: "就是当你填充输入时，使每个句子具有与数据集中的前一个相同的标记数量。",
			explain: "错误，而且由于我们在训练过程中对数据集进行了洗牌，因此查看数据集中的顺序是没有意义的。"
		},
	]}
/>

### 6．校对函数的用途是什么？
<Question
	choices={[
		{
			text: "它确保数据集中的所有序列具有相同的长度。",
			explain: "校对函数用于处理单个批处理，而不是整个数据集。此外，我们讨论的是通用的校对函数，而不是特定的  <code>DataCollatorWithPadding</code> "
		},
		{
			text："它把所有的样品一批一批地放在一起。",
			explain："正确！你可将校对函数作为 <code>DataLoader</code>函数的一个参数. 我们使用了 <code>DataCollatorWithPadding</code> 函数, 该函数对批次中的所有项目进行填充，使它们具有相同的长度。",
            correct:true
		},
		{
			text: "它预处理整个数据集。",
			explain: "这是一个预处理函数，而不是校对函数。"
		},
        {
			text: "它截断数据集中的序列。",
			explain: "校对函数用于处理单个批处理，而不是整个数据集。如果你对截断感兴趣，可以使用 < code > tokenizer </code > 的 truncate </code > 参数。"
		}
	]}
/>

### 7．当你用一个预先训练过的语言模型（例如 `bert-base-uncased`）实例化一个`AutoModelForXxx`类，这个类对应于一个不同于它所被训练的任务时会发生什么？
<Question
	choices={[
		{
			text: "什么都没有，但会出现一个警告。",
			explain: "确实出现警告，但这还不是全部！"
		},
		{
			text: "丢弃预训练模型的头部，取而代之的是一个适合任务的新头部。",
			explain: "这就是我们对 ＋－｜－－24－－｜－＋ Trainer ＋－｜－－25－－｜－＋ 所做的，而不是 Accelerate 库。再试一次！",
            correct: true
		},
		{
			text: "丢弃预先训练好的模型头部。",
			explain: "还需要做其他事情，再试一次！"
		},
        {
			text: "没有，因为模型仍然可以针对不同的任务进行微调。",
			explain: "这个经过训练的模特的头没有经过训练来解决这个问题，所以我们应该丢弃该头部！"
		}
	]}
/>

### 8．`TrainingArguments`的目的是什么？
<Question
	choices={[
		{
			text: "它包含了所有用于训练和评估的超参数。",
			explain: "正确！",
            correct: true
		},
		{
			text: "它指定模型的大小。",
			explain: "模型大小是由模型配置定义的，而不是类 ＋－｜－－26－－｜－＋ TrainingArguments ＋－｜－－27－－｜－＋ 。"
		},
		{
			text: "它只包含用于评估的超参数。",
			explain: "In the example, we specified where the model and its checkpoints will be saved. 再试一次！"
		},
        {
			text: "你可以轻松地计算与数据集相关的指标。",
			explain: "In the example, we used an ＋－｜－－28－－｜－＋evaluation_strategy＋－｜－－29－－｜－＋ as well, so this impacts evaluation. 再试一次！"
		}
	]}
/>

### 9．为什么要使用 Accelerate 库？
<Question
	choices={[
		{
			text: "它提供了对更快的模型的访问。",
			explain: "不，Accelerate 库不提供任何模型。"
		},
		{
			text: "它提供了一个高级 API，因此我不必实现自己的培训循环。",
			explain: "This is what we did with ＋－｜－－30－－｜－＋Trainer＋－｜－－31－－｜－＋, not the 🤗 Accelerate library. 再试一次！"
		},
		{
			text: "它使我们的训练循环工作在分布式策略上",
			explain: "正确! 随着加速，你的训练循环将为多个 gpu 和 TPUs 工作。",
            correct: true
		},
        {
			text: "它提供了更多的优化功能。",
			explain: "不，Accelerate 库不提供任何优化功能。"
		}
	]}
/>

{:else}
### 4．当你用一个预先训练过的语言模型（例如‘ bert-base-uncased’）实例化一个‘ tfautoodelforxxx’类时，会发生什么？
<Question
	choices={[
		{
			text: "什么都没有，但是你得到了一个警告。",
			explain: "你确实得到了警告，但这还不是全部！"
		},
		{
			text: "丢弃预训练模型的头部，并插入一个新的头部适合的任务。",
			explain: "需要一个特殊的标记来分隔这两个句子，但这不是唯一的事情！",
            correct: true
		},
		{
			text: "丢弃预先训练好的模型头部。",
			explain: "Something else needs to happen. 再试一次！"
		},
        {
			text: "没有，因为模型仍然可以针对不同的任务进行微调。",
			explain: "这个经过训练的模特的头没有经过训练来解决这个问题，所以我们应该丢掉这个头！"
		}
	]}
/>

### 5．来自“变压器”的 TensorFlow 模型已经是 Keras 模型，这有什么好处？
<Question
	choices={[
		{
			text: "该模型的工作在一个 TPU 的盒子。",
			explain: "差不多！还需要进行一些小的额外修改。例如，你需要运行 ＋－｜－－32－－｜－＋ TPUStrategy ＋－｜－－33－－｜－＋ scope 中的所有内容，包括模型的初始化。"
		},
		{
			text: "你可以利用现有的方法，如 ＋－｜－－34－－｜－＋ compile () ＋－｜－－35－－｜－＋ 、 ＋－｜－－36－－｜－＋ fit () ＋－｜－－37－－｜－＋ 和 ＋－｜－－38－－｜－＋ predict () ＋－｜－－39－－｜－＋ 。",
			explain: "正确! 一旦你有了这些数据，在这些数据上进行培训只需要很少的工作。",
            correct: true
		},
		{
			text: "你可以学习 Keras 和变形金刚。",
			explain: "没错，但我们要找的是别的东西:)",
			correct: true
		},
        {
			text: "困惑",
			explain: "Keras 帮助我们训练和评估模型，而不是计算与数据集相关的度量。"
		}
	]}
/>

### 6．如何定义自己的自定义度量？
<Question
	choices={[
		{
			text: "通过子类化 ＋－｜－－40－－｜－＋ tfkeras.metrics. Metric ＋－｜－－41－－｜－＋ 。",
			explain: "太好了！",
			correct: true
		},
		{
			text: "使用 Keras 函数 API。",
			explain: "再试一次！"
		},
		{
			text: "通过使用一个带签名的可调用 ＋－｜－－42－－｜－＋ metric _ fn (y _ true，y _ pred) ＋－｜－－43－－｜－＋ 。",
			explain: "正确！",
			correct: true
		},
        {
			text: "通过谷歌搜索。",
			explain: "这不是我们要找的答案，不过它应该能帮助你找到答案。",
			correct: true
		}
	]}
/>

{/if}